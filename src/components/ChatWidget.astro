<div
    id="chat-widget"
    class="fixed bottom-6 right-6 z-50 flex flex-col items-end"
>
    <!-- Chat Window -->
    <div
        id="chat-window"
        class="hidden mb-4 w-80 sm:w-96 bg-white dark:bg-slate-800 rounded-lg shadow-xl border border-gray-200 dark:border-slate-700 overflow-hidden transition-all duration-300 transform scale-90 opacity-0 origin-bottom-right flex flex-col h-[500px] pointer-events-none"
    >
        <!-- Header -->
        <div
            class="bg-blue-600 p-4 text-white flex justify-between items-center shrink-0"
        >
            <h3 class="font-bold">Chat with AI</h3>
            <span class="text-xs bg-blue-500 px-2 py-1 rounded">Beta</span>
        </div>

        <!-- Messages Area -->
        <div
            id="chat-messages"
            class="flex-1 p-4 overflow-y-auto space-y-4 bg-gray-50 dark:bg-slate-900 scroll-smooth"
        >
            <!-- Welcome Message -->
            <div class="flex gap-2">
                <div
                    class="w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center shrink-0"
                >
                    ðŸ¤–
                </div>
                <div
                    class="bg-white dark:bg-slate-800 p-3 rounded-lg rounded-tl-none shadow-sm border border-gray-100 dark:border-slate-700 text-sm max-w-[80%]"
                >
                    Hi! I'm the PlayTested.net AI. Ask me anything about the
                    articles on this site!
                </div>
            </div>
        </div>

        <!-- Input Area -->
        <div
            class="p-4 bg-white dark:bg-slate-800 border-t border-gray-200 dark:border-slate-700 shrink-0"
        >
            <form id="chat-form" class="flex gap-2">
                <input
                    type="text"
                    id="chat-input"
                    placeholder="Ask a question..."
                    class="flex-1 px-3 py-2 bg-gray-100 dark:bg-slate-900 border border-gray-300 dark:border-slate-700 rounded-md text-sm focus:outline-none focus:border-blue-500 text-gray-900 dark:text-gray-100"
                    autocomplete="off"
                />
                <button
                    type="submit"
                    class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        class="h-5 w-5"
                        viewBox="0 0 20 20"
                        fill="currentColor"
                    >
                        <path
                            d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"
                        ></path>
                    </svg>
                </button>
            </form>
        </div>
    </div>

    <!-- Toggle Button -->
    <button
        id="chat-toggle"
        class="bg-blue-600 hover:bg-blue-700 text-white w-14 h-14 rounded-full shadow-lg flex items-center justify-center transition-transform hover:scale-105 active:scale-95"
    >
        <!-- Chat Icon -->
        <svg
            id="icon-chat"
            xmlns="http://www.w3.org/2000/svg"
            class="h-8 w-8"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
        >
            <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"
            ></path>
        </svg>
        <!-- Close Icon -->
        <svg
            id="icon-close"
            xmlns="http://www.w3.org/2000/svg"
            class="h-8 w-8 hidden"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
        >
            <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M6 18L18 6M6 6l12 12"></path>
        </svg>
    </button>
</div>

<script>
    import { marked } from "marked";

    // Re-initialize on every page load (works with View Transitions)
    document.addEventListener("astro:page-load", () => {
        const toggleBtn = document.getElementById("chat-toggle");
        const chatWindow = document.getElementById("chat-window");
        const iconChat = document.getElementById("icon-chat");
        const iconClose = document.getElementById("icon-close");
        const chatForm = document.getElementById("chat-form");
        const chatInput = document.getElementById(
            "chat-input",
        ) as HTMLInputElement;
        const messagesContainer = document.getElementById("chat-messages");

        let isOpen = false;

        // Load history
        const storedHistory = sessionStorage.getItem("chatHistory");
        const chatHistory: Array<{ role: string; content: string }> =
            storedHistory ? JSON.parse(storedHistory) : [];

        // Helper: Toggle Window
        const toggleChat = () => {
            isOpen = !isOpen;
            if (isOpen) {
                chatWindow?.classList.remove("hidden", "pointer-events-none");
                // Small delay for transition
                setTimeout(() => {
                    chatWindow?.classList.remove("scale-90", "opacity-0");
                    chatWindow?.classList.add(
                        "scale-100",
                        "opacity-100",
                        "pointer-events-auto",
                    );
                }, 10);
                iconChat?.classList.add("hidden");
                iconClose?.classList.remove("hidden");
                chatInput?.focus();
            } else {
                chatWindow?.classList.remove(
                    "scale-100",
                    "opacity-100",
                    "pointer-events-auto",
                );
                chatWindow?.classList.add(
                    "scale-90",
                    "opacity-0",
                    "pointer-events-none",
                );
                setTimeout(() => chatWindow?.classList.add("hidden"), 300);
                iconChat?.classList.remove("hidden");
                iconClose?.classList.add("hidden");
            }
        };

        toggleBtn?.addEventListener("click", toggleChat);

        // Helper: Format Refs [1] -> [1](url)
        const formatRefs = (text: string, refMap: Record<string, string>) => {
            let result = text;
            for (const [ref, url] of Object.entries(refMap)) {
                // Escape brackets for regex
                const escaped = ref.replace(/\[/g, "\\[").replace(/\]/g, "\\]");
                const regex = new RegExp(escaped, "g");
                result = result.replace(regex, `[${ref}](${url})`);
            }
            return result;
        };

        // Helper: Append Message to UI
        const appendMessage = async (
            role: "user" | "assistant",
            text: string,
            refMap = {},
        ) => {
            const msgDiv = document.createElement("div");
            msgDiv.className =
                "flex gap-2 " + (role === "user" ? "flex-row-reverse" : "");

            // Icon
            const icon = document.createElement("div");
            icon.className = `w-8 h-8 rounded-full flex items-center justify-center shrink-0 ${
                role === "user"
                    ? "bg-blue-600 text-white"
                    : "bg-blue-100 dark:bg-blue-900"
            }`;
            icon.innerText = role === "user" ? "ðŸ‘¤" : "ðŸ¤–";

            // Content
            const contentBubble = document.createElement("div");
            contentBubble.className = `p-3 rounded-lg shadow-sm border text-sm max-w-[80%] prose dark:prose-invert prose-sm ${
                role === "user"
                    ? "bg-blue-600 text-white rounded-tr-none border-blue-600"
                    : "bg-white dark:bg-slate-800 rounded-tl-none border-gray-100 dark:border-slate-700"
            }`;

            if (role === "assistant" && !text) {
                // Loading spinner for empty assistant message initially
                contentBubble.innerHTML = `<span class="animate-pulse">...</span>`;
            } else {
                // Format links if provided
                const formattedText = formatRefs(text, refMap);
                const html = await marked.parse(formattedText);
                contentBubble.innerHTML = html;
            }

            msgDiv.appendChild(icon);
            msgDiv.appendChild(contentBubble);
            messagesContainer?.appendChild(msgDiv);
            messagesContainer?.scrollTo({
                top: messagesContainer.scrollHeight,
                behavior: "smooth",
            });

            return { msgDiv, contentBubble };
        };

        // Render History
        chatHistory.forEach((msg) =>
            appendMessage(msg.role as "user" | "assistant", msg.content),
        );

        // Submit Handler
        chatForm?.addEventListener("submit", async (e) => {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (!message) return;

            // Clear input
            chatInput.value = "";
            chatInput.disabled = true;

            // 1. Show User Message
            appendMessage("user", message);
            chatHistory.push({ role: "user", content: message });
            sessionStorage.setItem("chatHistory", JSON.stringify(chatHistory));

            // 2. Prepare Assistant Bubble
            const { contentBubble } = await appendMessage("assistant", "");

            try {
                // 3. Make Request
                const res = await fetch("/api/chat", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ messages: chatHistory }),
                });

                if (!res.ok) {
                    throw new Error(`Server error: ${res.status}`);
                }

                if (!res.body) throw new Error("No response body");

                // 4. Stream Reader Logic
                const reader = res.body.getReader();
                const decoder = new TextDecoder();

                let buffer = "";
                let accumulatedText = "";
                let referencesMap: Record<string, string> = {};
                let refsParsed = false;

                while (true) {
                    const { done, value } = await reader.read();

                    if (value) {
                        const chunk = decoder.decode(value, { stream: true });
                        buffer += chunk;
                    }

                    // STEP A: Check for References Block (Start of stream)
                    if (!refsParsed) {
                        const startTag = "<!--REFS:";
                        const endTag = ":REFS-->";
                        const startIndex = buffer.indexOf(startTag);
                        const endIndex = buffer.indexOf(endTag);

                        if (startIndex !== -1 && endIndex !== -1) {
                            // Extract JSON part
                            const jsonStr = buffer.substring(
                                startIndex + startTag.length,
                                endIndex,
                            );
                            try {
                                referencesMap = JSON.parse(jsonStr);
                            } catch (err) {
                                console.error("Failed to parse refs:", err);
                            }
                            // Remove the entire block including newline if present
                            // We construct "remaining" buffer starting after the endTag
                            let remaining = buffer.substring(
                                endIndex + endTag.length,
                            );
                            if (remaining.startsWith("\n"))
                                remaining = remaining.substring(1);

                            buffer = remaining;
                            refsParsed = true;
                        } else if (
                            buffer.length > 2000 &&
                            !buffer.includes(startTag)
                        ) {
                            // Safety: If buffer gets huge and no start tag, assume no refs sent (or using legacy model)
                            refsParsed = true;
                        }
                    }

                    // STEP B: Process SSE Lines only if we have passed key checks or if data is waiting
                    // We only process if we have parsed refs OR if we are sure there are no refs
                    if (refsParsed) {
                        const lines = buffer.split("\n");
                        // Save the last partial line back to buffer, UNLESS we are done
                        if (!done) {
                            buffer = lines.pop() || "";
                        } else {
                            buffer = ""; // Done, so process everything
                        }

                        for (const line of lines) {
                            const trim = line.trim();
                            if (
                                trim.startsWith("data: ") &&
                                trim !== "data: [DONE]"
                            ) {
                                try {
                                    const json = JSON.parse(trim.substring(6)); // skip "data: "
                                    const content =
                                        json.choices?.[0]?.delta?.content || "";
                                    accumulatedText += content;

                                    // Render Update
                                    const linkedText = formatRefs(
                                        accumulatedText,
                                        referencesMap,
                                    );
                                    contentBubble.innerHTML =
                                        await marked.parse(linkedText);
                                    messagesContainer?.scrollTo({
                                        top: messagesContainer.scrollHeight,
                                        behavior: "smooth",
                                    });
                                } catch (e) {
                                    // console.warn("JSON parse error for SSE line", e);
                                }
                            }
                        }
                    }

                    if (done) break;
                }

                // finalize
                chatHistory.push({
                    role: "assistant",
                    content: accumulatedText,
                });
                sessionStorage.setItem(
                    "chatHistory",
                    JSON.stringify(chatHistory),
                );
            } catch (err) {
                console.error(err);
                contentBubble.innerHTML = `<span class="text-red-500">Error: ${(err as Error).message}. Please try again.</span>`;
            } finally {
                chatInput.disabled = false;
                chatInput.focus();
            }
        });
    });
</script>
