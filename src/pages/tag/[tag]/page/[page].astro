---
import { getCollection, type CollectionEntry } from "astro:content";
import BlogLayout from "../../../../layouts/BlogLayout.astro";
import Header from "../../../../components/Header.astro";
import Footer from "../../../../components/Footer.astro";
import PostCard from "../../../../components/PostCard.astro";
import Pagination from "../../../../components/Pagination.astro";
import SiteOptions from "../../../../site.config.mjs";

const POSTS_PER_PAGE = SiteOptions.postsPerPage ?? 10;

// Define a union type for collections
type CombinedCollectionEntry = CollectionEntry<"article"> | CollectionEntry<"submissions">;

// 1) Generate dynamic paths for tag pages 2…N
export async function getStaticPaths() {
  const POSTS_PER_PAGE = SiteOptions.postsPerPage ?? 10;
  const articles = await getCollection("article");
  const submissions = await getCollection("submissions");
  const allContent: CombinedCollectionEntry[] = [...articles, ...submissions];

  const tagMap = new Map<string, number>();
  for (const post of allContent) {
    for (const t of post.data.tags ?? []) {
      const slug = t.toLowerCase().replace(/\s+/g, "-");
      tagMap.set(slug, (tagMap.get(slug) ?? 0) + 1);
    }
  }

  const paths: { params: { tag: string; page: string } }[] = [];
  for (const [slug, count] of tagMap.entries()) {
    const totalPages = Math.ceil(count / POSTS_PER_PAGE);
    for (let i = 2; i <= totalPages; i++) {
      paths.push({ params: { tag: slug, page: i.toString() } });
    }
  }
  return paths;
}

// 2) Extract params and fetch posts for this tag/page
const { tag, page } = Astro.params as { tag: string; page: string };
const currentPage = Number(page);

const articles = await getCollection("article");
const submissions = await getCollection("submissions");
const allContent: CombinedCollectionEntry[] = [...articles, ...submissions];

const posts = allContent
  .filter((post) =>
    (post.data.tags ?? []).some(
      (t) => t.toLowerCase().replace(/\s+/g, "-") === tag
    )
  )
  .sort((a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf());

// 3) Paginate
const totalPages = Math.ceil(posts.length / POSTS_PER_PAGE);
const start = (currentPage - 1) * POSTS_PER_PAGE;
const paginated = posts.slice(start, start + POSTS_PER_PAGE);

// 4) Prev/Next URLs
const base = `/tag/${tag}`;
const prevHref = currentPage <= 2 ? base : `${base}/page/${currentPage - 1}`;
const nextHref = currentPage < totalPages ? `${base}/page/${currentPage + 1}` : undefined;
const showPrev = currentPage > 1;
const showNext = currentPage < totalPages;

// 5) Pagination component data
const pageData = {
  data: paginated,
  url: {
    current: `${base}/page/${currentPage}`,
    prev: showPrev ? prevHref : undefined,
    next: showNext ? nextHref : undefined,
  },
  currentPage,
  lastPage: totalPages,
  size: POSTS_PER_PAGE,
  total: posts.length,
};

// Error check
if (currentPage < 1 || currentPage > totalPages) {
  throw Astro.error(404, "Page not found");
}

---

<BlogLayout
  title={`Tag: ${tag.replace(/-/g, " ")} – Page ${currentPage}`}
  description={`Page ${currentPage} of ${totalPages} for tag ${tag.replace(/-/g, " ")} on ${SiteOptions.siteTitle}`}
>
  <Fragment slot="head">
    {showPrev && <link rel="prev" href={prevHref} />}
    {showNext && nextHref && <link rel="next" href={nextHref} />}
  </Fragment>

  <Header showTitle={true} />

  <h1 class="text-3xl font-bold mb-8 text-center capitalize">
    Tag: {tag.replace(/-/g, " ")}
  </h1>

  <ul class="grid grid-cols-1 lg:grid-cols-2 gap-x-6 gap-y-6">
    {paginated.map((post) => (
      <PostCard post={post} />
    ))}
  </ul>

  <Pagination page={pageData} />

  <Footer />
</BlogLayout>